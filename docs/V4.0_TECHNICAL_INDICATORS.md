# Prometheus v4.0 - 技术指标体系设计

## 核心问题

**是否需要增加更多技术指标？**
- Stochastic（随机指标）
- ATR（平均真实波幅）
- CCI（商品通道指数）
- ADX（平均趋向指标）
- 以及其他...

**答案：需要，但不是固定的！** ⭐

---

## 一、设计哲学：指标工具箱 vs 固定指标

### ❌ 传统量化（固定指标）

```python
# 传统做法：硬编码固定指标
class TraditionalStrategy:
    def generate_signal(self, data):
        """
        固定使用特定指标组合
        """
        rsi = calculate_RSI(data, 14)
        macd = calculate_MACD(data, 12, 26, 9)
        
        if rsi < 30 and macd > 0:
            return 'BUY'
        elif rsi > 70 and macd < 0:
            return 'SELL'
        
        return 'HOLD'


# 问题：
❌ 市场变化，固定策略失效
❌ 无法适应不同市场状态
❌ 人为选择指标，可能不是最优
❌ 无法进化和改进
```

### ✅ Prometheus方式（指标工具箱）

```python
# Prometheus方式：提供工具箱，Agent自己选择
class IndicatorToolbox:
    """
    技术指标工具箱
    
    提供所有常用指标
    但不固定使用哪些
    由Agent的基因决定
    """
    
    def __init__(self):
        # 所有可用指标
        self.available_indicators = {
            # 趋势类
            'SMA': self.calculate_sma,
            'EMA': self.calculate_ema,
            'MACD': self.calculate_macd,
            'ADX': self.calculate_adx,
            
            # 动量类
            'RSI': self.calculate_rsi,
            'Stochastic': self.calculate_stochastic,
            'CCI': self.calculate_cci,
            'ROC': self.calculate_roc,
            
            # 波动率类
            'ATR': self.calculate_atr,
            'Bollinger': self.calculate_bollinger,
            'Keltner': self.calculate_keltner,
            
            # 成交量类
            'OBV': self.calculate_obv,
            'Volume_MA': self.calculate_volume_ma,
            'VWAP': self.calculate_vwap
        }


class AgentV4:
    def __init__(self):
        # Agent的基因决定使用哪些指标
        self.gene = {
            'indicator_selection': {
                'RSI': 0.8,        # 权重高，重视RSI
                'MACD': 0.6,       # 中等权重
                'ATR': 0.3,        # 低权重
                'Stochastic': 0.9, # 权重很高
                'ADX': 0.4,
                'CCI': 0.1,        # 几乎不用
                # ... 其他指标
            },
            
            'indicator_params': {
                'RSI_period': 14,   # RSI周期（也可以进化）
                'MACD_fast': 12,
                'MACD_slow': 26,
                # ... 参数也可以进化
            }
        }
    
    def calculate_technical_signal(self, data):
        """
        基于基因选择和组合指标
        
        不同Agent使用不同指标组合！
        """
        signals = {}
        
        # 只计算权重>0.2的指标（节省计算）
        for indicator, weight in self.gene['indicator_selection'].items():
            if weight > 0.2:
                signal = self.toolbox.calculate(indicator, data)
                signals[indicator] = signal * weight
        
        # 加权平均
        final_signal = sum(signals.values()) / sum(self.gene['indicator_selection'].values())
        
        return final_signal


# 优势：
✅ 每个Agent可以有不同的指标组合
✅ 市场会选择最有效的组合
✅ 自动发现人类未知的组合
✅ 适应市场变化
```

---

## 二、完整的技术指标工具箱

### 分类1：趋势指标（Trend Indicators）

```python
class TrendIndicators:
    """
    趋势指标：判断市场方向
    """
    
    @staticmethod
    def SMA(data, period=20):
        """
        简单移动平均（Simple Moving Average）
        
        用途：
        - 平滑价格
        - 判断趋势方向
        - 支撑/阻力位
        """
        return data.rolling(window=period).mean()
    
    @staticmethod
    def EMA(data, period=20):
        """
        指数移动平均（Exponential Moving Average）
        
        用途：
        - 对近期价格更敏感
        - 趋势判断
        - 金叉死叉
        """
        return data.ewm(span=period, adjust=False).mean()
    
    @staticmethod
    def MACD(data, fast=12, slow=26, signal=9):
        """
        MACD（Moving Average Convergence Divergence）
        
        用途：
        - 趋势强度
        - 买卖时机
        - 背离信号
        
        返回：
        - MACD线
        - 信号线
        - 柱状图
        """
        ema_fast = data.ewm(span=fast).mean()
        ema_slow = data.ewm(span=slow).mean()
        
        macd_line = ema_fast - ema_slow
        signal_line = macd_line.ewm(span=signal).mean()
        histogram = macd_line - signal_line
        
        return {
            'macd': macd_line,
            'signal': signal_line,
            'histogram': histogram
        }
    
    @staticmethod
    def ADX(high, low, close, period=14):
        """
        ADX（Average Directional Index）
        
        用途：
        - 判断趋势强度（不是方向！）
        - ADX > 25：强趋势
        - ADX < 20：震荡市
        
        这个很重要！⭐
        Agent可以根据ADX选择策略：
        - ADX高 → 趋势跟踪
        - ADX低 → 震荡策略
        """
        # 真实波幅
        tr1 = high - low
        tr2 = abs(high - close.shift())
        tr3 = abs(low - close.shift())
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        
        # 方向移动
        up_move = high - high.shift()
        down_move = low.shift() - low
        
        pos_dm = np.where((up_move > down_move) & (up_move > 0), up_move, 0)
        neg_dm = np.where((down_move > up_move) & (down_move > 0), down_move, 0)
        
        # 平滑
        atr = tr.rolling(window=period).mean()
        pos_di = 100 * pd.Series(pos_dm).rolling(window=period).mean() / atr
        neg_di = 100 * pd.Series(neg_dm).rolling(window=period).mean() / atr
        
        # ADX
        dx = 100 * abs(pos_di - neg_di) / (pos_di + neg_di)
        adx = dx.rolling(window=period).mean()
        
        return {
            'adx': adx,
            'plus_di': pos_di,
            'minus_di': neg_di
        }
```

### 分类2：动量指标（Momentum Indicators）

```python
class MomentumIndicators:
    """
    动量指标：判断超买超卖
    """
    
    @staticmethod
    def RSI(data, period=14):
        """
        RSI（Relative Strength Index）
        
        用途：
        - 超买超卖
        - RSI > 70：超买
        - RSI < 30：超卖
        """
        delta = data.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        
        return rsi
    
    @staticmethod
    def Stochastic(high, low, close, k_period=14, d_period=3):
        """
        随机指标（Stochastic Oscillator）⭐
        
        用途：
        - 超买超卖（比RSI更敏感）
        - K > D 金叉 → 买入
        - K < D 死叉 → 卖出
        - K > 80：超买
        - K < 20：超卖
        
        优势：
        - 对价格变化更敏感
        - 适合震荡市
        """
        lowest_low = low.rolling(window=k_period).min()
        highest_high = high.rolling(window=k_period).max()
        
        k = 100 * (close - lowest_low) / (highest_high - lowest_low)
        d = k.rolling(window=d_period).mean()
        
        return {
            'k': k,
            'd': d
        }
    
    @staticmethod
    def CCI(high, low, close, period=20):
        """
        CCI（Commodity Channel Index）⭐
        
        用途：
        - 识别超买超卖
        - CCI > 100：超买
        - CCI < -100：超卖
        - 穿越0轴：趋势改变
        
        优势：
        - 可以超过100（无上限）
        - 适合识别极端行情
        """
        tp = (high + low + close) / 3  # 典型价格
        sma_tp = tp.rolling(window=period).mean()
        mad = tp.rolling(window=period).apply(lambda x: np.abs(x - x.mean()).mean())
        
        cci = (tp - sma_tp) / (0.015 * mad)
        
        return cci
    
    @staticmethod
    def ROC(data, period=12):
        """
        ROC（Rate of Change）
        
        用途：
        - 价格变化率
        - 动量强度
        """
        roc = 100 * (data - data.shift(period)) / data.shift(period)
        return roc
    
    @staticmethod
    def Williams_R(high, low, close, period=14):
        """
        威廉指标（Williams %R）
        
        用途：
        - 超买超卖
        - 类似Stochastic，但反向
        """
        highest_high = high.rolling(window=period).max()
        lowest_low = low.rolling(window=period).min()
        
        wr = -100 * (highest_high - close) / (highest_high - lowest_low)
        
        return wr
```

### 分类3：波动率指标（Volatility Indicators）

```python
class VolatilityIndicators:
    """
    波动率指标：判断市场波动
    """
    
    @staticmethod
    def ATR(high, low, close, period=14):
        """
        ATR（Average True Range）⭐
        
        用途：
        - 测量波动性
        - 设置止损（如：2×ATR）
        - 判断市场状态
        
        非常重要！
        - ATR高：波动大，市场活跃
        - ATR低：波动小，市场平静
        
        Agent可以：
        - ATR高时减小仓位
        - ATR低时增加仓位
        """
        tr1 = high - low
        tr2 = abs(high - close.shift())
        tr3 = abs(low - close.shift())
        
        tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
        atr = tr.rolling(window=period).mean()
        
        return atr
    
    @staticmethod
    def Bollinger_Bands(data, period=20, std_dev=2):
        """
        布林带（Bollinger Bands）
        
        用途：
        - 价格通道
        - 超买超卖
        - 波动率
        
        策略：
        - 价格触及下轨 → 超卖，考虑买入
        - 价格触及上轨 → 超买，考虑卖出
        - 带宽收窄 → 波动即将增加（突破）
        """
        sma = data.rolling(window=period).mean()
        std = data.rolling(window=period).std()
        
        upper = sma + (std * std_dev)
        lower = sma - (std * std_dev)
        
        return {
            'upper': upper,
            'middle': sma,
            'lower': lower,
            'bandwidth': (upper - lower) / sma  # 带宽
        }
    
    @staticmethod
    def Keltner_Channel(high, low, close, period=20, multiplier=2):
        """
        肯特纳通道（Keltner Channel）
        
        用途：
        - 类似布林带，但基于ATR
        - 更平滑
        """
        ema = close.ewm(span=period).mean()
        atr = VolatilityIndicators.ATR(high, low, close, period)
        
        upper = ema + (multiplier * atr)
        lower = ema - (multiplier * atr)
        
        return {
            'upper': upper,
            'middle': ema,
            'lower': lower
        }
```

### 分类4：成交量指标（Volume Indicators）

```python
class VolumeIndicators:
    """
    成交量指标：确认趋势
    """
    
    @staticmethod
    def OBV(close, volume):
        """
        能量潮（On Balance Volume）
        
        用途：
        - 确认趋势
        - 背离信号
        
        逻辑：
        - 价格上涨日：+成交量
        - 价格下跌日：-成交量
        """
        obv = (np.sign(close.diff()) * volume).fillna(0).cumsum()
        return obv
    
    @staticmethod
    def Volume_MA(volume, period=20):
        """
        成交量移动平均
        
        用途：
        - 判断成交量异常
        - 放量 → 趋势确认
        """
        return volume.rolling(window=period).mean()
    
    @staticmethod
    def VWAP(high, low, close, volume):
        """
        VWAP（Volume Weighted Average Price）
        
        用途：
        - 交易基准价
        - 价格 > VWAP → 多头占优
        - 价格 < VWAP → 空头占优
        """
        typical_price = (high + low + close) / 3
        vwap = (typical_price * volume).cumsum() / volume.cumsum()
        return vwap
```

---

## 三、推荐的指标集合（v4.0）

### 核心指标（必须）⭐

```python
CORE_INDICATORS = {
    # 趋势类（2个）
    'EMA': {
        'category': 'trend',
        'priority': 'high',
        'reason': '快速反应趋势变化'
    },
    'ADX': {
        'category': 'trend',
        'priority': 'high',
        'reason': '判断是否有趋势（关键！）'
    },
    
    # 动量类（3个）
    'RSI': {
        'category': 'momentum',
        'priority': 'high',
        'reason': '经典超买超卖指标'
    },
    'Stochastic': {
        'category': 'momentum',
        'priority': 'high',
        'reason': '更敏感的超买超卖'
    },
    'CCI': {
        'category': 'momentum',
        'priority': 'medium',
        'reason': '识别极端行情'
    },
    
    # 波动率类（2个）
    'ATR': {
        'category': 'volatility',
        'priority': 'high',
        'reason': '风险管理必需（止损设置）'
    },
    'Bollinger': {
        'category': 'volatility',
        'priority': 'medium',
        'reason': '价格通道和波动率'
    },
    
    # 成交量类（1个）
    'OBV': {
        'category': 'volume',
        'priority': 'medium',
        'reason': '确认趋势'
    }
}

# 总计：8个核心指标
# 涵盖4大类别
# 足够全面，又不会太多
```

### 扩展指标（可选）

```python
EXTENDED_INDICATORS = {
    'MACD': '经典趋势动量',
    'Williams_R': '超买超卖补充',
    'ROC': '动量变化率',
    'Keltner': '通道补充',
    'VWAP': '成交量价格',
    'Volume_MA': '成交量确认'
}

# 这些可以作为Agent的可选工具
# 但不是必须的
```

---

## 四、Agent如何使用这些指标

### 基因编码示例

```python
class AgentGene:
    """Agent基因：编码指标偏好"""
    
    def generate_random_gene():
        """
        生成随机基因
        
        每个Agent对指标的偏好不同！
        """
        return {
            # 指标权重（0-1）
            'indicator_weights': {
                'EMA': random.uniform(0.3, 0.9),
                'ADX': random.uniform(0.4, 1.0),    # 重要
                'RSI': random.uniform(0.5, 1.0),    # 重要
                'Stochastic': random.uniform(0.3, 0.9),
                'CCI': random.uniform(0.0, 0.7),
                'ATR': random.uniform(0.6, 1.0),    # 重要（风控）
                'Bollinger': random.uniform(0.2, 0.8),
                'OBV': random.uniform(0.1, 0.6)
            },
            
            # 指标参数（可进化）
            'indicator_params': {
                'RSI_period': random.choice([7, 14, 21]),
                'Stochastic_period': random.choice([9, 14, 21]),
                'ATR_period': random.choice([7, 14, 21]),
                'EMA_fast': random.choice([5, 10, 20]),
                'EMA_slow': random.choice([20, 50, 100])
            },
            
            # 阈值（可进化）
            'thresholds': {
                'RSI_oversold': random.uniform(20, 35),
                'RSI_overbought': random.uniform(65, 80),
                'Stoch_oversold': random.uniform(15, 25),
                'Stoch_overbought': random.uniform(75, 85),
                'ADX_trend': random.uniform(20, 30)
            }
        }
```

### 信号生成示例

```python
class TechnicalSignalGenerator:
    """技术信号生成器"""
    
    def generate_signal(self, agent, market_data):
        """
        基于Agent基因生成信号
        
        不同Agent，不同信号！
        """
        signals = {}
        weights = agent.gene['indicator_weights']
        params = agent.gene['indicator_params']
        thresholds = agent.gene['thresholds']
        
        # 1. 趋势信号
        if weights['ADX'] > 0.3:
            adx_data = self.calculate_ADX(market_data)
            if adx_data['adx'] > thresholds['ADX_trend']:
                # 有趋势
                if adx_data['plus_di'] > adx_data['minus_di']:
                    signals['trend'] = 1.0  # 上升趋势
                else:
                    signals['trend'] = -1.0  # 下降趋势
            else:
                # 无趋势（震荡）
                signals['trend'] = 0.0
        
        # 2. 动量信号
        if weights['RSI'] > 0.3:
            rsi = self.calculate_RSI(market_data, params['RSI_period'])
            if rsi < thresholds['RSI_oversold']:
                signals['momentum_rsi'] = 1.0  # 超卖，买入
            elif rsi > thresholds['RSI_overbought']:
                signals['momentum_rsi'] = -1.0  # 超买，卖出
            else:
                signals['momentum_rsi'] = (50 - rsi) / 50  # 归一化
        
        if weights['Stochastic'] > 0.3:
            stoch = self.calculate_Stochastic(market_data, params['Stochastic_period'])
            if stoch['k'] < thresholds['Stoch_oversold']:
                signals['momentum_stoch'] = 1.0
            elif stoch['k'] > thresholds['Stoch_overbought']:
                signals['momentum_stoch'] = -1.0
            else:
                signals['momentum_stoch'] = 0.0
        
        # 3. 波动率信号（用于风险管理）
        if weights['ATR'] > 0.3:
            atr = self.calculate_ATR(market_data, params['ATR_period'])
            atr_normalized = atr / market_data['close'].iloc[-1]
            
            # ATR高 → 减小仓位信号
            signals['volatility'] = -atr_normalized * 10  # 归一化
        
        # 4. 加权综合
        weighted_signal = 0
        total_weight = 0
        
        for signal_name, signal_value in signals.items():
            # 找到对应的指标权重
            for indicator_name, weight in weights.items():
                if indicator_name.lower() in signal_name.lower():
                    weighted_signal += signal_value * weight
                    total_weight += weight
                    break
        
        # 归一化到-1到1
        if total_weight > 0:
            final_signal = weighted_signal / total_weight
        else:
            final_signal = 0
        
        return final_signal
```

---

## 五、指标过多的风险：过拟合

### 问题：指标越多越好？

```
❌ 错误想法：
"我用50个指标，肯定比用5个好！"

实际情况：
指标太多 → 过拟合 → 实盘失效

原因：
1. 指标之间相关性高（重复信息）
2. 复杂模型容易拟合噪音
3. 计算成本高
4. 难以解释
```

### 解决方案：让进化选择

```python
class IndicatorSelection:
    """
    指标选择机制
    
    不是人为决定用哪些指标
    而是让进化算法选择
    """
    
    def evolve_indicator_set(self, population):
        """
        进化过程中自动优化指标组合
        
        过程：
        1. 初始：随机指标权重
        2. 评估：哪些Agent表现好
        3. 繁衍：保留表现好的Agent的指标组合
        4. 变异：尝试新的组合
        5. 重复
        
        结果：
        - 市场会告诉我们哪些指标有用
        - 可能发现意想不到的组合
        - 自动适应市场变化
        """
        pass
    
    def analyze_indicator_usage(self, top_agents):
        """
        分析顶尖Agent使用了哪些指标
        
        Example结果：
        Top 10 Agent的指标权重：
        - ATR: 0.85（几乎所有人都重视）
        - ADX: 0.78（重要）
        - RSI: 0.72（重要）
        - Stochastic: 0.45（中等）
        - CCI: 0.15（不太重要）
        
        发现：
        - ATR最重要（风险管理）
        - ADX很关键（判断市场状态）
        - CCI用处不大（可以移除）
        ```
```

---

## 六、推荐方案

### v4.0配置：精简高效

```python
V4_0_INDICATORS = {
    # 必需指标（6个）
    'core': {
        'ADX': '趋势强度（最重要！）',
        'RSI': '超买超卖',
        'Stochastic': '超买超卖（更敏感）',
        'ATR': '波动率（风控必需）',
        'EMA': '趋势方向',
        'Bollinger': '价格通道'
    },
    
    # 可选指标（2个）
    'optional': {
        'CCI': '极端行情',
        'OBV': '成交量确认'
    }
}

# 总计：8个指标
# 不多不少，刚刚好！
```

### Agent基因编码

```python
# 每个Agent的基因中包含
agent.gene = {
    'indicator_weights': {
        'ADX': 0.7,        # 这个Agent重视ADX
        'RSI': 0.9,        # 非常重视RSI
        'Stochastic': 0.3, # 不太重视随机指标
        'ATR': 0.8,        # 重视风险管理
        'EMA': 0.5,
        'Bollinger': 0.4,
        'CCI': 0.1,        # 几乎不用
        'OBV': 0.2
    },
    
    # 参数也可以进化
    'indicator_params': {
        'RSI_period': 14,
        'ADX_period': 14,
        'ATR_period': 14,
        # ...
    }
}

# 不同Agent → 不同组合 → 策略多样性！
```

---

## 七、总结

### 问题回答

**Q: 是否需要增加Stochastic、ATR、CCI、ADX等指标？**

**A: 需要！而且这些都很重要！**

```
推荐添加：
✅ Stochastic（随机指标）- 敏感的超买超卖
✅ ATR（真实波幅）- 风险管理必需
✅ ADX（趋势强度）- 最重要！判断市场状态
✅ CCI（商品通道）- 极端行情识别

完整工具箱（8个核心指标）：
1. ADX    - 趋势强度⭐⭐⭐
2. ATR    - 波动率⭐⭐⭐
3. RSI    - 超买超卖⭐⭐⭐
4. Stochastic - 超买超卖（敏感）⭐⭐
5. EMA    - 趋势方向⭐⭐
6. Bollinger - 价格通道⭐⭐
7. CCI    - 极端行情⭐
8. OBV    - 成交量确认⭐
```

### 设计原则

```
1. 提供工具箱，不固定使用 ✅
   - 让Agent自己选择
   - 由基因控制权重
   - 进化发现最优组合

2. 不要太多指标 ✅
   - 8-10个足够
   - 避免过拟合
   - 保持可解释性

3. 参数可进化 ✅
   - RSI周期：7/14/21?
   - ATR周期：14/21?
   - 让市场选择

4. 关注关键指标 ✅
   - ADX：趋势 vs 震荡
   - ATR：风险管理
   - RSI/Stoch：时机
```

**工具箱策略 + 进化选择 = 最优方案！** 🎯✨

---

最后更新：2025年12月1日

