# Prometheus v4.0 - 资产扩展路线图（优化版）

## 用户策略（三阶段科学扩展）

### 核心思路 ⭐

```
阶段1：BTC单一
  ↓ 验证基础
阶段2：BTC + 强相关币种
  ↓ 利用相关性，降低风险
阶段3：全市场分类筛选
  ↓ 科学分类，精准选择
最终模式：动态优质币种池
```

**这个思路的优势：**
1. ✅ **渐进式**：每阶段风险可控
2. ✅ **科学性**：利用相关性原理
3. ✅ **系统化**：最终建立分类体系
4. ✅ **可扩展**：为长期发展奠定基础

---

## 阶段1：BTC单一（0-3个月）

### 目标
验证Prometheus核心系统的可行性

### 配置
```python
{
    'assets': ['BTC/USDT'],
    'timeframe': '0-3个月',
    'agent_count': 100-500,
    'initial_capital': 100000,
    'focus': '核心算法验证'
}
```

### 验证内容
```
核心功能：
✅ Agent进化算法
✅ 主脑决策系统
✅ 监督者管理机制
✅ 英灵殿系统
✅ 公告板系统
✅ 权限系统

关键指标：
✅ Agent存活率 > 30%
✅ 群体多样性 > 0.6
✅ 月均收益 > 3%
✅ 系统稳定性 > 99%
✅ 夏普比率 > 1.5
```

### 成功标准（进入下一阶段）
```
必要条件：
✅ 稳定运行90天无重大故障
✅ Agent群体盈利能力验证
✅ 多样性保持机制有效
✅ 风险控制机制完善

系统准备：
✅ 数据接口稳定
✅ 计算资源充足
✅ 代码优化完成
✅ 监控系统完善
```

---

## 阶段2：BTC + 强相关币种（3-6个月）

### 核心策略：利用相关性

**为什么先做强相关币种？** 🤔

```
优势1：风险可控
├─ 强相关币种与BTC走势相似
├─ 不会出现完全相反的行情
├─ 风险评估模型可以复用
└─ 降低系统性风险的同时保持多样性

优势2：策略迁移
├─ BTC的策略可以迁移到相关币种
├─ Agent不需要完全重新学习
├─ 减少学习曲线
└─ 快速验证多资产能力

优势3：跨资产套利
├─ 相关性偏离 → 套利机会
├─ 相对强弱策略
├─ 配对交易
└─ 资金流动追踪

优势4：数据特征相似
├─ 技术指标适用性强
├─ 市场结构相似
├─ 交易模式接近
└─ 容易建立统一框架
```

### 强相关币种分析

#### 相关性矩阵（2023-2025数据）

```
币种与BTC的相关性（Pearson相关系数）：

极高相关（0.85-0.95）：
├─ ETH（以太坊）: 0.92 ⭐⭐⭐⭐⭐
├─ BNB（币安币）: 0.88 ⭐⭐⭐⭐
└─ SOL（Solana）: 0.87 ⭐⭐⭐⭐

高相关（0.75-0.85）：
├─ ADA（Cardano）: 0.83 ⭐⭐⭐
├─ AVAX（Avalanche）: 0.82 ⭐⭐⭐
├─ MATIC（Polygon）: 0.81 ⭐⭐⭐
└─ DOT（Polkadot）: 0.80 ⭐⭐⭐

中等相关（0.65-0.75）：
├─ LINK（Chainlink）: 0.73
├─ UNI（Uniswap）: 0.71
└─ XRP（Ripple）: 0.68

低相关（< 0.65）：
├─ Stablecoins: ~0.0（USDT, USDC等）
└─ 部分DeFi币：0.4-0.6
```

### 推荐配置（阶段2）

#### 方案A：保守（推荐初期）

```python
{
    'assets': ['BTC', 'ETH'],
    'correlation_target': 0.90+,
    'timeframe': '3-4个月',
    
    'allocation': {
        'BTC': 0.70,    # 70%（核心）
        'ETH': 0.30     # 30%（扩展）
    },
    
    'agent_count': 500-1000,
    
    'strategy_focus': [
        '相对强弱',
        '配对交易',
        'BTC/ETH套利',
        '资金分配优化'
    ]
}
```

**验证目标：**
```
✅ 双资产系统稳定运行
✅ 跨资产策略盈利验证
✅ 动态资金分配有效性
✅ Agent多资产适应能力
```

#### 方案B：进取（4-6个月）

```python
{
    'assets': ['BTC', 'ETH', 'BNB', 'SOL'],
    'correlation_target': 0.85+,
    'timeframe': '4-6个月',
    
    'allocation': {
        'BTC': 0.50,    # 50%（核心）
        'ETH': 0.25,    # 25%
        'BNB': 0.15,    # 15%
        'SOL': 0.10     # 10%
    },
    
    'agent_count': 1000-2000,
    
    'strategy_focus': [
        '板块轮动（高相关组内）',
        '多资产组合优化',
        '相关性套利',
        'Agent币种专业化初步'
    ]
}
```

### 相关性套利策略

```python
class CorrelationArbitrage:
    """
    利用高相关币种的相关性偏离进行套利
    """
    
    def detect_divergence(self, btc_return, eth_return):
        """
        检测偏离
        
        正常：BTC +5%, ETH +5% (相关性维持)
        偏离：BTC +5%, ETH +2% (相关性下降)
        """
        # 计算30天滚动相关性
        historical_corr = self.calculate_rolling_correlation(
            window=30
        )
        
        # 当前相关性
        current_corr = self.calculate_correlation(
            btc_return, eth_return
        )
        
        # 偏离检测
        if current_corr < historical_corr - 0.15:
            # 相关性异常下降
            return self.generate_arbitrage_signal(btc_return, eth_return)
    
    def generate_arbitrage_signal(self, btc_return, eth_return):
        """
        生成套利信号
        
        逻辑：相关性会回归
        - 如果ETH涨幅落后BTC → 做多ETH
        - 如果BTC涨幅落后ETH → 做多BTC
        """
        if btc_return > eth_return + 0.03:  # BTC超前3%+
            return {
                'action': 'LONG_ETH',  # 做多ETH（追赶）
                'reason': 'ETH落后，预期追赶BTC'
            }
        elif eth_return > btc_return + 0.03:  # ETH超前3%+
            return {
                'action': 'LONG_BTC',  # 做多BTC（追赶）
                'reason': 'BTC落后，预期追赶ETH'
            }
```

### 配对交易（Pairs Trading）

```python
class PairsTrading:
    """
    BTC-ETH配对交易
    
    经典量化策略，利用均值回归
    """
    
    def calculate_spread(self, btc_price, eth_price):
        """
        计算价格差
        
        使用对数价格比
        """
        spread = np.log(btc_price / eth_price)
        return spread
    
    def detect_signal(self, current_spread, historical_spread):
        """
        检测交易信号
        
        当spread偏离均值超过2个标准差时：
        - spread过高 → 做空BTC，做多ETH
        - spread过低 → 做多BTC，做空ETH
        """
        mean = np.mean(historical_spread)
        std = np.std(historical_spread)
        
        z_score = (current_spread - mean) / std
        
        if z_score > 2:
            # spread过高，预期回归
            return {
                'BTC': 'SHORT',
                'ETH': 'LONG',
                'reason': 'BTC相对ETH过贵'
            }
        elif z_score < -2:
            # spread过低，预期回归
            return {
                'BTC': 'LONG',
                'ETH': 'SHORT',
                'reason': 'ETH相对BTC过贵'
            }
```

---

## 阶段3：全市场分类筛选（6-12个月）

### 核心策略：科学分类体系

**为什么需要分类？** 🔍

```
原因：
1. 币种太多（320+个）
2. 质量参差不齐
3. 需要系统化筛选
4. 建立长期框架

目标：
建立科学的币种分类和评估体系
不是盲目扩展，而是精准选择
```

### 币种分类体系（多维度）

#### 维度1：市值分类

```python
class MarketCapClassification:
    """市值分类"""
    
    categories = {
        'MEGA_CAP': {
            'name': '超大市值',
            'threshold': 100_000_000_000,  # >1000亿美元
            'coins': ['BTC', 'ETH'],
            'characteristics': {
                'volatility': '低（2-5%）',
                'liquidity': '极高',
                'stability': '最稳定',
                'risk': '低',
                'suitable_strategy': '大仓位趋势跟踪'
            }
        },
        
        'LARGE_CAP': {
            'name': '大市值',
            'threshold': 10_000_000_000,  # 100亿-1000亿
            'coins': ['BNB', 'SOL', 'XRP', 'ADA', 'AVAX', 'DOT'],
            'characteristics': {
                'volatility': '中（3-8%）',
                'liquidity': '高',
                'stability': '较稳定',
                'risk': '中低',
                'suitable_strategy': '中等仓位趋势跟踪'
            }
        },
        
        'MID_CAP': {
            'name': '中市值',
            'threshold': 1_000_000_000,  # 10亿-100亿
            'coins': ['LINK', 'UNI', 'MATIC', 'ATOM', 'APT', 'ARB'],
            'characteristics': {
                'volatility': '高（5-15%）',
                'liquidity': '中',
                'stability': '中等',
                'risk': '中',
                'suitable_strategy': '小仓位波段交易'
            }
        },
        
        'SMALL_CAP': {
            'name': '小市值',
            'threshold': 100_000_000,  # 1亿-10亿
            'coins': ['众多小币种'],
            'characteristics': {
                'volatility': '极高（10-30%）',
                'liquidity': '低',
                'stability': '不稳定',
                'risk': '高',
                'suitable_strategy': '极小仓位投机'
            }
        },
        
        'MICRO_CAP': {
            'name': '微市值',
            'threshold': 0,  # <1亿
            'coins': ['大量长尾币种'],
            'characteristics': {
                'volatility': '暴涨暴跌',
                'liquidity': '极低',
                'stability': '极不稳定',
                'risk': '极高',
                'suitable_strategy': '不建议交易'
            }
        }
    }
```

#### 维度2：板块分类

```python
class SectorClassification:
    """板块/赛道分类"""
    
    sectors = {
        'LAYER1': {
            'name': 'Layer1公链',
            'coins': ['BTC', 'ETH', 'SOL', 'AVAX', 'ADA', 'DOT', 'ATOM'],
            'correlation_internal': 0.80,  # 板块内高相关
            'characteristics': '基础设施，相对稳定'
        },
        
        'DEFI': {
            'name': 'DeFi去中心化金融',
            'coins': ['UNI', 'AAVE', 'SUSHI', 'COMP', 'MKR', 'CRV'],
            'correlation_internal': 0.85,
            'characteristics': '受监管影响大，波动高'
        },
        
        'LAYER2': {
            'name': 'Layer2扩容',
            'coins': ['MATIC', 'ARB', 'OP', 'IMX'],
            'correlation_internal': 0.75,
            'characteristics': '受以太坊影响，技术驱动'
        },
        
        'NFT': {
            'name': 'NFT/元宇宙',
            'coins': ['APE', 'BLUR', 'SAND', 'MANA'],
            'correlation_internal': 0.70,
            'characteristics': '情绪驱动，波动极大'
        },
        
        'MEME': {
            'name': 'Meme币',
            'coins': ['DOGE', 'SHIB', 'PEPE'],
            'correlation_internal': 0.60,
            'characteristics': '纯情绪，极高风险'
        },
        
        'EXCHANGE': {
            'name': '交易所平台币',
            'coins': ['BNB', 'OKB', 'FTT'],
            'correlation_internal': 0.70,
            'characteristics': '受平台影响，相对稳定'
        },
        
        'INFRASTRUCTURE': {
            'name': '基础设施',
            'coins': ['LINK', 'GRT', 'FIL', 'AR'],
            'correlation_internal': 0.65,
            'characteristics': '技术价值，长期导向'
        }
    }
```

#### 维度3：技术指标分类

```python
class TechnicalClassification:
    """技术指标分类"""
    
    def classify_by_volatility(self, coin):
        """按波动性分类"""
        volatility = self.calculate_30day_volatility(coin)
        
        if volatility < 0.03:
            return 'LOW_VOL'      # 低波动（BTC, USDT）
        elif volatility < 0.06:
            return 'MID_VOL'      # 中波动（ETH, BNB）
        elif volatility < 0.10:
            return 'HIGH_VOL'     # 高波动（SOL, AVAX）
        else:
            return 'EXTREME_VOL'  # 极端波动（小币种）
    
    def classify_by_liquidity(self, coin):
        """按流动性分类"""
        daily_volume = self.get_average_daily_volume(coin)
        
        if daily_volume > 1_000_000_000:
            return 'ULTRA_LIQUID'  # 超高流动性（BTC, ETH）
        elif daily_volume > 100_000_000:
            return 'HIGH_LIQUID'   # 高流动性（主流币）
        elif daily_volume > 10_000_000:
            return 'MID_LIQUID'    # 中等流动性
        else:
            return 'LOW_LIQUID'    # 低流动性（风险）
    
    def classify_by_trend(self, coin):
        """按趋势强度分类"""
        adx = self.calculate_ADX(coin)  # 平均趋向指标
        
        if adx > 40:
            return 'STRONG_TREND'   # 强趋势（适合趋势策略）
        elif adx > 25:
            return 'MODERATE_TREND' # 中等趋势
        else:
            return 'RANGING'        # 震荡（适合震荡策略）
```

#### 维度4：相关性分类

```python
class CorrelationClassification:
    """相关性分类"""
    
    def classify_by_btc_correlation(self, coin):
        """与BTC的相关性"""
        corr = self.calculate_correlation_with_btc(coin)
        
        if corr > 0.85:
            return 'HIGHLY_CORRELATED'    # 高相关（ETH, BNB）
        elif corr > 0.70:
            return 'CORRELATED'           # 相关（多数主流币）
        elif corr > 0.50:
            return 'WEAKLY_CORRELATED'    # 弱相关
        else:
            return 'UNCORRELATED'         # 不相关（机会or风险）
    
    def find_correlation_clusters(self, coins):
        """
        聚类分析：找到相关性集群
        
        Example输出：
        Cluster 1: [BTC, ETH, BNB, SOL] - 核心集群
        Cluster 2: [UNI, AAVE, SUSHI] - DeFi集群
        Cluster 3: [DOGE, SHIB] - Meme集群
        """
        pass
```

### 综合评分系统

```python
class ComprehensiveScoring:
    """
    综合评分系统
    
    对每个币种进行多维度评分
    """
    
    def calculate_score(self, coin):
        """
        综合评分（0-100）
        
        考虑因素：
        1. 市值（20分）
        2. 流动性（20分）
        3. 波动性（15分）- 适度波动得分高
        4. 数据质量（15分）
        5. 历史表现（10分）
        6. 项目基本面（10分）
        7. 社区活跃度（5分）
        8. 技术创新（5分）
        """
        score = 0
        
        # 1. 市值（越大越好，但有上限）
        market_cap_score = self._score_market_cap(coin.market_cap)
        score += market_cap_score * 0.20
        
        # 2. 流动性（越高越好）
        liquidity_score = self._score_liquidity(coin.daily_volume)
        score += liquidity_score * 0.20
        
        # 3. 波动性（适度最好，太低太高都不好）
        volatility_score = self._score_volatility(coin.volatility)
        score += volatility_score * 0.15
        
        # 4. 数据质量
        data_quality_score = self._score_data_quality(coin)
        score += data_quality_score * 0.15
        
        # 5. 历史表现
        performance_score = self._score_performance(coin.returns)
        score += performance_score * 0.10
        
        # 6. 基本面
        fundamental_score = self._score_fundamentals(coin)
        score += fundamental_score * 0.10
        
        # 7. 社区
        community_score = self._score_community(coin.social_metrics)
        score += community_score * 0.05
        
        # 8. 技术
        tech_score = self._score_technology(coin.tech_metrics)
        score += tech_score * 0.05
        
        return score
    
    def _score_volatility(self, volatility):
        """
        波动性评分
        
        太低（<2%）：缺乏机会 → 40分
        适度（2-8%）：理想 → 100分
        偏高（8-15%）：有机会但风险大 → 70分
        极高（>15%）：风险太大 → 30分
        """
        if volatility < 0.02:
            return 40
        elif volatility < 0.08:
            return 100
        elif volatility < 0.15:
            return 70
        else:
            return 30
```

### 最终筛选流程

```python
class CoinSelectionPipeline:
    """币种筛选流水线"""
    
    def select_coins(self, all_coins, target_count=20):
        """
        筛选流程
        
        Input: 320+个币种
        Output: 精选20个币种
        """
        # 第一轮：硬性条件过滤
        filtered_coins = []
        for coin in all_coins:
            if self._meets_hard_requirements(coin):
                filtered_coins.append(coin)
        
        logger.info(f"第一轮过滤: {len(all_coins)} → {len(filtered_coins)}")
        
        # 第二轮：综合评分
        scored_coins = []
        for coin in filtered_coins:
            score = self.scoring_system.calculate_score(coin)
            scored_coins.append((coin, score))
        
        # 按分数排序
        scored_coins.sort(key=lambda x: x[1], reverse=True)
        
        # 第三轮：多样性检查
        final_coins = self._ensure_diversity(scored_coins, target_count)
        
        logger.info(f"最终筛选: {len(final_coins)}个币种")
        
        return final_coins
    
    def _meets_hard_requirements(self, coin):
        """
        硬性条件（必须满足）
        """
        return (
            coin.market_cap > 500_000_000 and          # 市值>5亿
            coin.daily_volume > 10_000_000 and         # 日交易量>1000万
            coin.data_completeness > 0.95 and          # 数据完整度>95%
            coin.listing_age > 180 and                 # 上线>6个月
            coin.exchange_count > 3 and                # 至少3家交易所
            not coin.has_major_security_issues         # 无重大安全问题
        )
    
    def _ensure_diversity(self, scored_coins, target_count):
        """
        确保多样性
        
        不是只选前N个高分币种
        而是确保：
        - 不同市值级别都有
        - 不同板块都有覆盖
        - 相关性分散
        """
        selected = []
        
        # 确保核心币种
        selected.extend(self._select_by_tier('MEGA_CAP', scored_coins, 2))
        selected.extend(self._select_by_tier('LARGE_CAP', scored_coins, 8))
        selected.extend(self._select_by_tier('MID_CAP', scored_coins, 10))
        
        # 确保板块覆盖
        sectors = ['LAYER1', 'DEFI', 'LAYER2', 'INFRASTRUCTURE']
        for sector in sectors:
            if not self._has_sector_coverage(selected, sector):
                top_in_sector = self._get_top_in_sector(scored_coins, sector)
                selected.append(top_in_sector)
        
        return selected[:target_count]
```

### 阶段3输出：最终币种池

```python
# 预期输出示例

final_coin_pool = {
    'MEGA_CAP': ['BTC', 'ETH'],  # 40%资金
    
    'LARGE_CAP': [  # 40%资金
        'BNB', 'SOL', 'XRP', 'ADA', 
        'AVAX', 'DOT', 'MATIC', 'ATOM'
    ],
    
    'MID_CAP': [  # 15%资金
        'LINK', 'UNI', 'APT', 'ARB',
        'OP', 'LDO', 'IMX', 'SAND'
    ],
    
    'OPPORTUNITY': [],  # 5%资金（动态）
    
    'total_count': 20,
    
    'rebalance_frequency': 'monthly',  # 每月重新评估
    
    'selection_criteria': {
        'market_cap_min': 500_000_000,
        'volume_min': 10_000_000,
        'score_min': 60,
        'data_quality_min': 0.95
    }
}
```

---

## 最终模式：动态优质币种池

### 核心机制

```python
class DynamicCoinPool:
    """
    动态币种池
    
    不是固定20个币种
    而是根据市场变化动态调整
    """
    
    def __init__(self):
        self.core_pool = ['BTC', 'ETH']  # 永远保留
        self.main_pool = []              # 8-12个主流
        self.opportunity_pool = []       # 5-8个机会币
        
        self.max_total = 25
        self.rebalance_interval = 30  # 天
    
    def monthly_rebalance(self):
        """
        每月重新评估
        
        流程：
        1. 重新评分所有候选币种
        2. 移除不合格币种
        3. 加入新兴优质币种
        4. 调整资金配置
        """
        # 1. 评分
        all_candidates = self.get_all_candidates()
        scored = [(c, self.calculate_score(c)) for c in all_candidates]
        
        # 2. 移除低分币种
        self.main_pool = [
            c for c, s in scored 
            if s > 70 and c in self.main_pool
        ]
        
        # 3. 加入新币种
        new_candidates = [
            c for c, s in scored 
            if s > 75 and c not in self.main_pool
        ]
        self.main_pool.extend(new_candidates[:5])
        
        # 4. 限制总数
        self.main_pool = self.main_pool[:12]
        
        logger.info(f"Rebalance完成: {len(self.main_pool)}个主力币种")
    
    def add_emergency_opportunity(self, coin, reason):
        """
        紧急添加机会币种
        
        Example：某个币种突然有重大利好
        """
        if len(self.opportunity_pool) < 8:
            self.opportunity_pool.append({
                'coin': coin,
                'reason': reason,
                'added_at': datetime.now(),
                'allocation': 0.02  # 2%仓位
            })
    
    def remove_failed_coins(self):
        """
        移除失败币种
        
        触发条件：
        - 单日暴跌 > 30%
        - 流动性骤降
        - 重大安全事件
        """
        pass
```

---

## 总结对比

### 原方案 vs 用户优化方案

```
原方案（我的）：
阶段1: BTC
阶段2: BTC + ETH
阶段3: 8-10个主流币
阶段4: 20-30个优质币

用户方案（更优）：⭐
阶段1: BTC
阶段2: BTC + 强相关币种（科学扩展）
阶段3: 全市场分类筛选（系统化）
最终: 动态优质池（长期机制）

用户方案的优势：
✅ 阶段2利用相关性，风险更可控
✅ 阶段3建立分类体系，更系统
✅ 最终模式更科学、可持续
✅ 每个阶段都有明确的科学依据
```

### 关键创新点

```
1. 相关性驱动扩展
   不是盲目加币种
   而是利用相关性降低风险

2. 科学分类体系
   不是拍脑袋选币
   而是建立系统化框架

3. 动态管理机制
   不是一成不变
   而是持续优化调整

4. 长期视角
   不是短期试验
   而是建立可扩展架构
```

---

## 实施建议

### 时间表

```
Month 1-3: 阶段1（BTC）
├─ 验证核心系统
├─ 优化算法
└─ 积累数据

Month 4-5: 阶段2A（BTC + ETH）
├─ 验证双资产
├─ 开发相关性策略
└─ 测试配对交易

Month 5-6: 阶段2B（加入BNB, SOL）
├─ 扩展到4个高相关币
├─ 优化资金分配
└─ Agent专业化

Month 7-9: 阶段3准备
├─ 研究所有币种
├─ 建立分类体系
├─ 开发评分系统

Month 10-12: 阶段3实施
├─ 筛选最终币种池
├─ 逐步扩展到20个
└─ 建立动态机制

Month 13+: 最终模式
├─ 动态优质池运行
├─ 月度重新平衡
└─ 持续优化
```

**用户的思路非常棒！科学、系统、可持续！** 🎯✨

---

最后更新：2025年12月1日

