# 宕机恢复系统 - 完整设计方案

## 📋 **设计时间**
2025-12-03 01:15

---

## 🎯 **核心目标**

在系统崩溃、意外重启或主动停止后，能够完整恢复系统状态，继续进行交易，确保：
- 数据零丢失
- 状态完整恢复
- 账务数据一致性
- 交易连续性

---

## 📦 **功能模块**

### **1. 账簿系统恢复** ⭐

#### **1.1 公共账簿恢复**
```python
# 需要恢复的数据
- 所有Agent的交易记录（完整历史）
- 每个Agent的PnL统计
- 胜率、交易次数、连胜/连败记录
- 性能排名历史
- 已归档的死亡Agent数据
```

#### **1.2 私有账簿恢复**
```python
# 每个Agent的私有账簿
- 当前资金余额
- 虚拟持仓（symbol, side, amount, entry_price, timestamp）
- 实际持仓状态
- 个人交易历史
- 未平仓盈亏
```

#### **持久化方案**
```python
# 文件格式
persistence/
├── public_ledger.json          # 公共账簿快照
├── private_ledgers/
│   ├── LiveAgent_01.json       # 各Agent私有账簿
│   ├── LiveAgent_02.json
│   └── ...
└── ledger_checkpoint.json      # 最后保存时间戳
```

---

### **2. Agent完整状态恢复** ⭐

#### **2.1 核心属性**
```python
{
    "agent_id": "LiveAgent_01",
    "state": "MATURE",               # AgentState枚举值
    "gene": {                         # 完整基因信息
        "max_position_size": 0.05,
        "stop_loss": 0.02,
        "take_profit": 0.05,
        # ... 所有基因参数
    },
    "personality": {                  # 性格特征
        "optimism": 0.65,
        "aggression": 0.45,
        "risk_tolerance": 0.7,
        # ... 所有性格参数
    },
    "emotional_state": {              # 情绪状态
        "stress": 0.3,
        "confidence": 0.8,
        "fear": 0.2,
        "greed": 0.4
    },
    "current_capital": 12500.0,       # 当前资金
    "initial_capital": 10000.0,       # 初始资金
    "total_pnl": 2500.0,              # 总盈亏
    "win_rate": 0.65,                 # 胜率
    "trade_count": 45,                # 交易次数
    "consecutive_wins": 3,            # 连胜
    "consecutive_losses": 0,          # 连败
    "max_consecutive_losses": 5,     # 最大连败
    "days_alive": 15,                 # 存活天数
    "birth_time": "2025-11-18T10:30:00",
    "last_update": "2025-12-03T01:12:44",
    
    # 拼死一搏状态
    "is_in_last_stand": false,
    "last_stand_start_time": null,
    "last_stand_initial_capital": null,
    
    # 交易权限
    "trading_level": 3,               # 权限等级
    "medals": ["first_profit", "survivor_30d"],  # 奖章列表
    
    # 市场适应性
    "fitness_score": 0.75,
    "market_adaptation": 0.8
}
```

#### **持久化方案**
```python
persistence/
├── agents/
│   ├── LiveAgent_01_state.json
│   ├── LiveAgent_02_state.json
│   └── ...
└── agents_checkpoint.json
```

---

### **3. 英灵殿系统恢复** ⭐

#### **3.1 英灵殿数据**
```python
{
    "valhalla": {
        "heroes": [
            {
                "agent_id": "LiveAgent_42",
                "death_time": "2025-11-25T15:30:00",
                "death_reason": "NATURAL_DEATH",
                "final_capital": 25000.0,
                "lifetime_pnl": 15000.0,
                "lifetime_trades": 120,
                "win_rate": 0.75,
                "days_alive": 45,
                "gene": {...},           # 完整基因
                "personality": {...},     # 完整性格
                "achievements": ["..."],  # 成就列表
                "legacy": "传奇交易员"
            }
        ],
        "total_heroes": 5,
        "last_review_time": "2025-12-03T01:00:00"
    }
}
```

#### **持久化方案**
```python
persistence/
└── valhalla.json
```

---

### **4. 三方对账系统** ⭐⭐⭐ (最重要)

#### **4.1 对账流程**
```
启动恢复系统
    ↓
1. 读取公共账簿
    ↓
2. 读取所有私有账簿
    ↓
3. 查询OKX实际持仓
    ↓
4. 三方数据对账
    ↓
┌─────────────────┐
│  数据一致？     │
└─────────────────┘
    ↙         ↘
  YES         NO
    ↓           ↓
  通过      进入纠正流程
    ↓
正式开始交易
```

#### **4.2 对账项目**

| 对账项 | 公共账簿 | 私有账簿 | OKX实际 | 纠正优先级 |
|--------|----------|----------|---------|------------|
| Agent总持仓量 | ✓ | ✓ | ✓ | P0 |
| 持仓方向 | ✓ | ✓ | ✓ | P0 |
| 入场价格 | ✓ | ✓ | - | P1 |
| 持仓时间 | ✓ | ✓ | - | P2 |
| 虚拟资金 | ✓ | ✓ | - | P1 |
| 实际持仓tag | - | ✓ | ✓ | P0 |

#### **4.3 数据不一致的纠正策略**

##### **情况A：OKX持仓 > 账簿记录**
```python
# 可能原因：账簿未及时更新 / 手动交易 / 数据丢失
纠正策略：
1. 查询OKX订单历史，找出未记录的订单
2. 反向推算应该属于哪个Agent（根据订单tag、时间、金额）
3. 补全账簿记录
4. 如果无法确定归属，创建"孤儿订单"警告
```

##### **情况B：账簿记录 > OKX持仓**
```python
# 可能原因：止损/爆仓/手动平仓未记录
纠正策略：
1. 查询OKX订单历史，确认订单是否已平仓
2. 如果已平仓，更新账簿为已平仓状态
3. 计算实际盈亏，更新Agent资金
4. 记录为"系统外平仓"事件
```

##### **情况C：公共账簿 ≠ 私有账簿**
```python
# 可能原因：数据不同步 / 保存时间不一致
纠正策略：
1. 比较两个账簿的最后更新时间戳
2. 以最新时间戳的数据为准
3. 同步更新另一个账簿
4. 记录数据不一致事件，供审计
```

##### **情况D：持仓方向不一致**
```python
# 严重错误，需要人工介入
纠正策略：
1. 立即暂停系统启动
2. 生成详细的对账报告
3. 提示管理员手动审核
4. 提供自动纠正建议（以OKX实际为准）
```

---

### **5. Supervisor状态恢复**

#### **5.1 需要恢复的数据**
```python
{
    "supervisor": {
        "environment_pressure": 0.35,
        "last_mastermind_decision": "2025-12-03T01:00:00",
        "agent_rankings": [
            {"agent_id": "LiveAgent_01", "rank": 1, "score": 0.85},
            ...
        ],
        "market_state_history": [
            {"time": "...", "trend": "强上升趋势", "difficulty": 0.43},
            ...
        ],
        "system_cycle_count": 156,      # 已运行周期数
        "total_runtime_hours": 52.0,    # 总运行时长
        "last_save_time": "2025-12-03T01:12:44"
    }
}
```

---

### **6. Mastermind状态恢复**

#### **6.1 需要恢复的数据**
```python
{
    "mastermind": {
        "total_capital": 100000.0,
        "strategy_history": [
            {"time": "...", "decision": "...", "reason": "..."},
            ...
        ],
        "intervention_mode": "human",   # 或 "llm"
        "last_strategic_decision": "2025-12-03T00:55:00"
    }
}
```

---

### **7. 持久化机制**

#### **7.1 自动保存策略**
```python
# 保存触发条件
1. 每N个周期自动保存 (N=5, 可配置)
2. 每次交易执行后立即保存
3. Agent死亡时立即保存
4. 系统正常退出时保存
5. 检测到Ctrl+C时优雅保存

# 保存内容
- 增量保存：只保存变更的Agent
- 全量快照：每小时生成一次完整快照
- 备份机制：保留最近3个快照
```

#### **7.2 文件结构**
```
persistence/
├── snapshots/                      # 完整快照
│   ├── snapshot_20251203_010000.zip
│   ├── snapshot_20251203_020000.zip
│   └── snapshot_20251203_030000.zip (最多保留3个)
│
├── incremental/                    # 增量保存
│   ├── checkpoint_latest.json      # 最新检查点
│   ├── public_ledger.json
│   ├── private_ledgers/
│   ├── agents/
│   ├── valhalla.json
│   ├── supervisor_state.json
│   └── mastermind_state.json
│
└── recovery_log.txt                # 恢复日志
```

---

## 🔧 **技术实现**

### **8. 恢复流程（伪代码）**

```python
class RecoverySystem:
    """宕机恢复系统"""
    
    def restore(self):
        """完整恢复流程"""
        logger.info("=" * 70)
        logger.info("🔄 启动宕机恢复系统...")
        logger.info("=" * 70)
        
        # 1. 检查是否有恢复数据
        if not self.has_recovery_data():
            logger.info("✅ 未发现恢复数据，执行全新启动")
            return None
        
        # 2. 加载最后的检查点
        checkpoint = self.load_latest_checkpoint()
        logger.info(f"📂 找到检查点: {checkpoint['timestamp']}")
        logger.info(f"   - 周期数: {checkpoint['cycle_count']}")
        logger.info(f"   - 运行时长: {checkpoint['runtime_hours']:.1f}小时")
        logger.info(f"   - Agent数量: {checkpoint['agent_count']}")
        
        # 3. 恢复各个组件
        logger.info("\n🔄 开始恢复组件...")
        
        # 3.1 恢复公共账簿
        public_ledger = self.restore_public_ledger()
        logger.info(f"   ✅ 公共账簿: {len(public_ledger.records)}条记录")
        
        # 3.2 恢复所有Agent
        agents = self.restore_all_agents()
        logger.info(f"   ✅ Agent恢复: {len(agents)}个")
        
        # 3.3 恢复私有账簿
        private_ledgers = self.restore_private_ledgers(agents)
        logger.info(f"   ✅ 私有账簿: {len(private_ledgers)}个")
        
        # 3.4 恢复英灵殿
        valhalla = self.restore_valhalla()
        logger.info(f"   ✅ 英灵殿: {len(valhalla.heroes)}位英雄")
        
        # 3.5 恢复Supervisor
        supervisor = self.restore_supervisor(public_ledger, agents)
        logger.info(f"   ✅ Supervisor状态恢复")
        
        # 3.6 恢复Mastermind
        mastermind = self.restore_mastermind()
        logger.info(f"   ✅ Mastermind状态恢复")
        
        # 4. 三方对账
        logger.info("\n🔍 开始三方对账...")
        reconciliation = self.reconcile_positions(
            public_ledger, 
            private_ledgers, 
            self.okx
        )
        
        if reconciliation.is_consistent():
            logger.info("   ✅ 对账通过！数据一致")
        else:
            logger.warning("   ⚠️  发现数据不一致，开始纠正...")
            self.correct_inconsistencies(reconciliation)
        
        # 5. 生成恢复报告
        self.generate_recovery_report(reconciliation)
        
        # 6. 询问是否继续
        logger.info("\n" + "=" * 70)
        logger.info("✅ 系统恢复完成！")
        logger.info("=" * 70)
        
        return {
            'agents': agents,
            'public_ledger': public_ledger,
            'private_ledgers': private_ledgers,
            'supervisor': supervisor,
            'mastermind': mastermind,
            'valhalla': valhalla,
            'cycle_count': checkpoint['cycle_count']
        }
    
    def reconcile_positions(self, public_ledger, private_ledgers, okx):
        """三方对账"""
        report = ReconciliationReport()
        
        # 获取OKX实际持仓
        okx_positions = okx.fetch_positions()
        
        for agent_id, private_ledger in private_ledgers.items():
            # 私有账簿持仓
            private_pos = private_ledger.get_positions()
            
            # 公共账簿持仓（通过agent_id过滤）
            public_pos = public_ledger.get_agent_positions(agent_id)
            
            # OKX持仓（通过tag过滤）
            okx_pos = [p for p in okx_positions if p['tag'] == agent_id]
            
            # 对比
            if not self._positions_match(private_pos, public_pos, okx_pos):
                inconsistency = Inconsistency(
                    agent_id=agent_id,
                    private=private_pos,
                    public=public_pos,
                    okx=okx_pos
                )
                report.add_inconsistency(inconsistency)
        
        return report
    
    def correct_inconsistencies(self, report):
        """纠正数据不一致"""
        for inconsistency in report.inconsistencies:
            logger.warning(f"   ⚠️  {inconsistency.agent_id} 数据不一致")
            
            # 策略：以OKX实际持仓为准
            okx_pos = inconsistency.okx
            
            if len(okx_pos) == 0:
                # OKX无持仓，但账簿有记录 → 已被平仓
                logger.info(f"      → 检测到已平仓，更新账簿")
                self._mark_as_closed(inconsistency.agent_id)
            
            elif len(okx_pos) > len(inconsistency.private):
                # OKX持仓多于账簿 → 补全记录
                logger.info(f"      → 检测到未记录订单，补全账簿")
                self._add_missing_orders(inconsistency.agent_id, okx_pos)
            
            else:
                # 其他情况 → 同步到OKX实际
                logger.info(f"      → 同步到OKX实际状态")
                self._sync_to_okx(inconsistency.agent_id, okx_pos)
```

---

## 📊 **恢复报告示例**

```
======================================================================
🔄 宕机恢复报告
======================================================================

恢复时间: 2025-12-03 10:30:00
上次保存: 2025-12-03 01:12:44 (9小时17分钟前)

【系统状态】
✅ 公共账簿: 3,450条记录
✅ 私有账簿: 10个Agent
✅ Agent恢复: 10个 (8个存活, 2个死亡)
✅ 英灵殿: 5位英雄
✅ 运行周期: 156个周期
✅ 总运行时长: 52.0小时

【Agent详情】
  LiveAgent_01: 存活, 资金=$12,500, PnL=+$2,500, 持仓=1
  LiveAgent_02: 存活, 资金=$11,200, PnL=+$1,200, 持仓=1
  LiveAgent_03: 死亡, 原因=自然死亡
  ...

【三方对账】
🔍 对账项目: 10个Agent
   ✅ 一致: 8个
   ⚠️  不一致: 2个 (已自动纠正)

【不一致详情】
  LiveAgent_04:
    - 问题: 账簿记录持仓1笔，OKX实际无持仓
    - 原因: 已被止损平仓
    - 纠正: 更新账簿为已平仓，计算盈亏=-$150
  
  LiveAgent_07:
    - 问题: 公共账簿与私有账簿资金不一致
    - 原因: 保存时间差
    - 纠正: 同步到最新状态

【启动决策】
✅ 系统状态正常，可以继续交易
✅ 所有数据已恢复且一致

======================================================================
```

---

## ✅ **补充功能点**

### **9. 你提到的功能 + 我的补充**

| # | 功能 | 来源 | 优先级 | 说明 |
|---|------|------|--------|------|
| 1 | 恢复所有账簿 | 用户 | P0 | 公共+私有账簿 |
| 2 | 恢复Agent信息（含基因） | 用户 | P0 | 完整状态恢复 |
| 3 | 恢复英灵殿系统 | 用户 | P1 | 死亡Agent记录 |
| 4 | 三方对账+纠正 | 用户 | P0 | 最重要！ |
| 5 | **持久化存储机制** | 补充 | P0 | 自动保存 |
| 6 | **时间戳验证** | 补充 | P0 | 防止脏数据 |
| 7 | **Supervisor状态恢复** | 补充 | P1 | 环境压力、排名等 |
| 8 | **Mastermind状态恢复** | 补充 | P1 | 战略历史 |
| 9 | **增量保存机制** | 补充 | P1 | 性能优化 |
| 10 | **恢复日志审计** | 补充 | P2 | 可追溯性 |
| 11 | **优雅退出信号捕获** | 补充 | P0 | Ctrl+C保存 |
| 12 | **多版本快照备份** | 补充 | P1 | 防止数据损坏 |
| 13 | **孤儿订单处理** | 补充 | P1 | 无法归属的订单 |
| 14 | **Agent情绪状态恢复** | 补充 | P2 | 压力、信心等 |
| 15 | **交易权限/奖章恢复** | 补充 | P1 | 完整Agent状态 |

---

## 🚀 **实施计划**

### **Phase 1: 基础持久化 (2-3小时)**
- [ ] 设计数据结构
- [ ] 实现自动保存机制
- [ ] 实现基础恢复功能

### **Phase 2: 三方对账 (3-4小时)**
- [ ] 实现对账逻辑
- [ ] 实现不一致检测
- [ ] 实现自动纠正策略

### **Phase 3: 完整恢复 (2-3小时)**
- [ ] Agent完整状态恢复
- [ ] 英灵殿恢复
- [ ] Supervisor/Mastermind恢复

### **Phase 4: 测试与优化 (2-3小时)**
- [ ] 模拟各种崩溃场景
- [ ] 测试数据不一致纠正
- [ ] 性能优化

**总预计时间: 9-13小时**

---

## 📝 **重要注意事项**

### **数据安全**
1. **原子性保存**: 使用临时文件+重命名，防止保存过程中崩溃
2. **数据校验**: 保存时计算checksum，恢复时验证
3. **多版本备份**: 保留最近3个快照，防止数据损坏

### **性能考虑**
1. **增量保存**: 只保存变更的Agent，减少I/O
2. **异步保存**: 保存操作不阻塞交易主循环
3. **压缩存储**: 快照文件使用zip压缩

### **用户体验**
1. **恢复确认**: 恢复后显示详细报告，让用户确认是否继续
2. **手动恢复**: 提供命令行工具手动触发恢复
3. **恢复模式**: 支持"完全恢复"和"仅恢复Agent"两种模式

---

## 🎯 **成功标准**

1. ✅ 系统崩溃后能100%恢复所有Agent状态
2. ✅ 三方对账通过率>95%（允许5%的合理差异）
3. ✅ 恢复时间<30秒（10个Agent）
4. ✅ 数据保存不影响交易性能（<100ms）
5. ✅ 支持任意时间点恢复（24小时内）

---

## 📌 **后续优化方向**

1. **云端备份**: 定期上传快照到云存储
2. **热备份**: 主从双实例，自动failover
3. **时光机**: 支持恢复到任意历史时间点
4. **智能纠正**: AI分析不一致原因，提供最优纠正方案
5. **实时同步**: 使用数据库代替文件系统，支持分布式

---

**🎯 明天的任务清单准备好了！这个系统将让Prometheus v4.0拥有真正的"不死之身"！**

